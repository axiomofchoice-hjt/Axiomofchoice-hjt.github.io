(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{487:function(t,a,s){"use strict";s.r(a);var e=s(17),n=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("blockquote",[a("p",[t._v("围绕“原地算法”的结构对称性，从 inplace merge 与 stable partition 两个经典 O(n log n) 算法切入，讨论 rotate 操作在分治中的核心作用，以及快速排序与归并排序在原地稳定算法里的镜像关系。")])]),t._v(" "),a("h2",{attrs:{id:"_1-从双指针-merge-开始讲起"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-从双指针-merge-开始讲起"}},[t._v("#")]),t._v(" 1. 从双指针 merge 开始讲起")]),t._v(" "),a("p",[t._v("说到合并 (merge) 两个有序数组，最简单强大的做法就是双指针。两个指针指向两个数组的开始位置，不断把较小元素放到 buffer 数组，对应指针向后移动。最后把 buffer 里的元素移动回原数组。")]),t._v(" "),a("p",[t._v("这个过程如下图所示：")]),t._v(" "),a("p",[a("img",{attrs:{src:"/animation/1a8ff1-0.webp",alt:"merge_to"}})]),t._v(" "),a("p",[t._v("这个算法在 C++ "),a("a",{attrs:{href:"https://en.cppreference.com/w/cpp/algorithm/merge.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("std::merge"),a("OutboundLink")],1),t._v(" 里亦有记载。")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("但是这个算法需要一个 "),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("O")]),a("mo",[t._v("(")]),a("mi",[t._v("n")]),a("mo",[t._v(")")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(n)")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.75em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),a("span",{staticClass:"mopen"},[t._v("(")]),a("span",{staticClass:"mord mathit"},[t._v("n")]),a("span",{staticClass:"mclose"},[t._v(")")])])])]),t._v(" 的额外空间复杂度（就是 buffer 数组），有没有办法可以原地进行呢？有的兄弟，原地算法有很多小巧思，这篇文章也算是个开头。")]),t._v(" "),a("p",[t._v("“原地”其实有两种含义，一是算法的结果直接写回原数组，比如 C++ "),a("code",[t._v("std::inplace_merge")]),t._v(" 就是这个含义；二是 "),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("O")]),a("mo",[t._v("(")]),a("mn",[t._v("1")]),a("mo",[t._v(")")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(1)")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.75em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),a("span",{staticClass:"mopen"},[t._v("(")]),a("span",{staticClass:"mord mathrm"},[t._v("1")]),a("span",{staticClass:"mclose"},[t._v(")")])])])]),t._v(" 的额外空间复杂度，有时会允许 "),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("O")]),a("mo",[t._v("(")]),a("mi",[t._v("log")]),a("mi",[t._v("n")]),a("mo",[t._v(")")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(\\log n)")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.75em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),a("span",{staticClass:"mopen"},[t._v("(")]),a("span",{staticClass:"mop"},[t._v("lo"),a("span",{staticStyle:{"margin-right":"0.01389em"}},[t._v("g")])]),a("span",{staticClass:"mord mathit"},[t._v("n")]),a("span",{staticClass:"mclose"},[t._v(")")])])])]),t._v(" 的递归栈，这篇文章的“原地”都是这个含义。")]),t._v(" "),a("h2",{attrs:{id:"_2-rotate-区间旋转算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-rotate-区间旋转算法"}},[t._v("#")]),t._v(" 2. rotate 区间旋转算法")]),t._v(" "),a("p",[t._v("原地算法基本绕不开 rotate（区间旋转），把两个相邻区间 "),a("code",[t._v("[A B]")]),t._v(" 原地变成 "),a("code",[t._v("[B A]")]),t._v("，保持区间内部顺序不变。这个方法不唯一，最经典的做法是三次翻转法（或手摇算法）：先分别翻转区间 A 和区间 B，再整体翻转整个区间 "),a("code",[t._v("[A B]")]),t._v("，就能得到 "),a("code",[t._v("[B A]")]),t._v("。")]),t._v(" "),a("p",[t._v("这个过程如下图所示：")]),t._v(" "),a("p",[a("img",{attrs:{src:"/animation/1a8ff1-1.webp",alt:"rotate"}})]),t._v(" "),a("p",[t._v("这个算法在 C++ "),a("a",{attrs:{href:"https://en.cppreference.com/w/cpp/algorithm/rotate.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("std::rotate"),a("OutboundLink")],1),t._v(" 里亦有记载。")]),t._v(" "),a("h2",{attrs:{id:"_3-inplace-merge-的分治算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-inplace-merge-的分治算法"}},[t._v("#")]),t._v(" 3. inplace merge 的分治算法")]),t._v(" "),a("p",[t._v("（我们约定 merge 的接口是，输入一个长度为 n 的数组 arr 和一个位置 pos，"),a("code",[t._v("arr[0] ... arr[pos - 1]")]),t._v(" 属于第一个有序数组 A，"),a("code",[t._v("arr[pos] ... arr[n - 1]")]),t._v(" 属于有序数组 B，merge 的结果是合并两个有序数组为 "),a("code",[t._v("arr[0] ... arr[n]")]),t._v("）")]),t._v(" "),a("p",[t._v("怎么做呢？答案是简化的快速排序。")]),t._v(" "),a("p",[t._v("我们选数组中的一个数 pivot = "),a("code",[t._v("arr[x]")]),t._v("（马上讲怎么选这个数）。由于两个数组一开始是有序的，每个数组天然划分成小于 pivot、大于等于 pivot 两个区间，一共 4 个区间。只要把中间两个区间旋转一下，这时候变成了左边两个有序数组，右边也是两个有序数组，递归即可。")]),t._v(" "),a("p",[t._v("那么怎么选择 pivot 呢？可以选择中位数，我们模拟双指针的方法可以把中位数求出来，但是这样会有找中位数的开销。所以更合理的做法是取两个有序数组里较长的那个的中间值，另一个数组就用二分查找来划分。这样最坏情况也能 1:3 的比例划分数组，整个算法时间复杂度 "),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("O")]),a("mo",[t._v("(")]),a("mi",[t._v("n")]),a("mi",[t._v("log")]),a("mi",[t._v("n")]),a("mo",[t._v(")")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(n \\log n)")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.75em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),a("span",{staticClass:"mopen"},[t._v("(")]),a("span",{staticClass:"mord mathit"},[t._v("n")]),a("span",{staticClass:"mop"},[t._v("lo"),a("span",{staticStyle:{"margin-right":"0.01389em"}},[t._v("g")])]),a("span",{staticClass:"mord mathit"},[t._v("n")]),a("span",{staticClass:"mclose"},[t._v(")")])])])]),t._v("，读者自证不难。因为需要调用栈，额外空间复杂度 "),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("O")]),a("mo",[t._v("(")]),a("mi",[t._v("log")]),a("mi",[t._v("n")]),a("mo",[t._v(")")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(\\log n)")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.75em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),a("span",{staticClass:"mopen"},[t._v("(")]),a("span",{staticClass:"mop"},[t._v("lo"),a("span",{staticStyle:{"margin-right":"0.01389em"}},[t._v("g")])]),a("span",{staticClass:"mord mathit"},[t._v("n")]),a("span",{staticClass:"mclose"},[t._v(")")])])])]),t._v("。")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("我们来看一个例子，初始数组 "),a("code",[t._v("[2, 5, 6, 7, 12, 19], [1, 4, 6, 7, 8, 11, 13, 14, 14, 18]")]),t._v("：")]),t._v(" "),a("p",[a("img",{attrs:{src:"/img/1a8ff1-0.drawio.png",alt:"img"}})]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("这个算法在 C++ "),a("a",{attrs:{href:"https://en.cppreference.com/w/cpp/algorithm/inplace_merge.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("std::inplace_merge"),a("OutboundLink")],1),t._v(" 里亦有记载（如果空间不够的话）。")]),t._v(" "),a("p",[t._v("我们顺便浏览一下 libstdc++ 的实现。")]),t._v(" "),a("ol",[a("li",[a("a",{attrs:{href:"https://github.com/gcc-mirror/gcc/blob/releases/gcc-15.2.0/libstdc%2B%2B-v3/include/bits/stl_algo.h#L2594",target:"_blank",rel:"noopener noreferrer"}},[t._v("std::inplace_merge"),a("OutboundLink")],1),t._v(" 会直接调用 std::__inplace_merge。")]),t._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/gcc-mirror/gcc/blob/releases/gcc-15.2.0/libstdc%2B%2B-v3/include/bits/stl_algo.h#L2487",target:"_blank",rel:"noopener noreferrer"}},[t._v("std::__inplace_merge"),a("OutboundLink")],1),t._v(" 如果申请 buffer 失败，调用 std::__merge_without_buffer。")]),t._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/gcc-mirror/gcc/blob/releases/gcc-15.2.0/libstdc%2B%2B-v3/include/bits/stl_algo.h#L2437",target:"_blank",rel:"noopener noreferrer"}},[t._v("std::__merge_without_buffer"),a("OutboundLink")],1),t._v(" 这里就是上面算法的实现了。")])]),t._v(" "),a("h2",{attrs:{id:"_4-变成严格的原地算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-变成严格的原地算法"}},[t._v("#")]),t._v(" 4. 变成严格的原地算法")]),t._v(" "),a("p",[t._v("严格的原地算法，也就是额外空间复杂度 "),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("O")]),a("mo",[t._v("(")]),a("mn",[t._v("1")]),a("mo",[t._v(")")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(1)")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.75em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),a("span",{staticClass:"mopen"},[t._v("(")]),a("span",{staticClass:"mord mathrm"},[t._v("1")]),a("span",{staticClass:"mclose"},[t._v(")")])])])]),t._v("，怎么做呢？需要略微修改一下。")]),t._v(" "),a("p",[t._v("上面算法的 "),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("O")]),a("mo",[t._v("(")]),a("mi",[t._v("log")]),a("mi",[t._v("n")]),a("mo",[t._v(")")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(\\log n)")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.75em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),a("span",{staticClass:"mopen"},[t._v("(")]),a("span",{staticClass:"mop"},[t._v("lo"),a("span",{staticStyle:{"margin-right":"0.01389em"}},[t._v("g")])]),a("span",{staticClass:"mord mathit"},[t._v("n")]),a("span",{staticClass:"mclose"},[t._v(")")])])])]),t._v(" 空间是调用栈造成的。调用栈的作用，是为了恢复调用方的状态，那么什么情况下不用栈也能恢复状态呢？对于区间范围，我们需要把数组划分到确定的位置，最简单的就是 2 的整数幂位置，这样通过简单的二进制运算就能恢复了。对于初始两个有序数组的分界线，这个可以直接遍历一遍找到。")]),t._v(" "),a("p",[t._v("具体算法就是，先确定大于等于数组大小的 2 的整数幂（C++ 的 "),a("code",[t._v("std::bit_ceil")]),t._v("）为 block。把整个数组按大小为 block 分块，每个 block 块划分为 "),a("code",[t._v("block / 2")]),t._v(" 和剩下部分，然后 "),a("code",[t._v("block /= 2")]),t._v(" 重复分块的步骤，直到 block 变成 1。")]),t._v(" "),a("p",[t._v("伪代码如下：")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("inplace_merge")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" size_t n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("size_t block "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" std"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("bit_ceil")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" block "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" block "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("size_t i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" block"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" block "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 划分为 [i, i + block / 2 - 1] [i + block / 2, i + std::min(block, n) - 1] */")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("于是问题就剩下如何划分了。由于一开始数组是两个有序数组组成，遍历一遍可以找到两个有序数组的分界线。通过双指针找第 "),a("code",[t._v("block / 2")]),t._v(" 小的数，确定了这些就是一个 rotate 完成划分了。")]),t._v(" "),a("h2",{attrs:{id:"_5-stable-partition-的分治算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-stable-partition-的分治算法"}},[t._v("#")]),t._v(" 5. stable partition 的分治算法")]),t._v(" "),a("p",[t._v("划分 (partition) 是快速排序里的一个步骤，就是给定一个数字 pivot，把数组里小于 pivot 的放前面，大于等于 pivot 的放后面。这里再加个稳定的要求，就是保持小于 pivot 的数字之间顺序不变，大于等于同理。")]),t._v(" "),a("p",[t._v("怎么做呢？答案是简化的归并排序。")]),t._v(" "),a("p",[t._v("我们取中间位置，左右两边分别递归求解，这样左右分别得到小于 pivot、大于等于 pivot 的两个区间，一共 4 个区间。这时候只要把中间两个区间旋转一下，就结束了。旋转 "),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("O")]),a("mo",[t._v("(")]),a("mi",[t._v("n")]),a("mo",[t._v(")")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(n)")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.75em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),a("span",{staticClass:"mopen"},[t._v("(")]),a("span",{staticClass:"mord mathit"},[t._v("n")]),a("span",{staticClass:"mclose"},[t._v(")")])])])]),t._v(" 就行了，整个算法时间复杂度 "),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("O")]),a("mo",[t._v("(")]),a("mi",[t._v("n")]),a("mi",[t._v("log")]),a("mi",[t._v("n")]),a("mo",[t._v(")")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(n \\log n)")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.75em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),a("span",{staticClass:"mopen"},[t._v("(")]),a("span",{staticClass:"mord mathit"},[t._v("n")]),a("span",{staticClass:"mop"},[t._v("lo"),a("span",{staticStyle:{"margin-right":"0.01389em"}},[t._v("g")])]),a("span",{staticClass:"mord mathit"},[t._v("n")]),a("span",{staticClass:"mclose"},[t._v(")")])])])]),t._v("，读者自证不难。")]),t._v(" "),a("p",[t._v("这个算法在 C++ "),a("a",{attrs:{href:"https://en.cppreference.com/w/cpp/algorithm/stable_partition.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("std::stable_partition"),a("OutboundLink")],1),t._v(" 里亦有记载（如果空间不够的话）。")]),t._v(" "),a("h2",{attrs:{id:"_6-从-merge-到-partition"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-从-merge-到-partition"}},[t._v("#")]),t._v(" 6. 从 merge 到 partition")]),t._v(" "),a("p",[t._v("有没有发现，我讲 stable partition 算法时好像在倒着讲述 inplace merge 算法。")]),t._v(" "),a("p",[t._v("merge 和 partition 仿佛就是关于时间对称的两个算法。它们甚至你中有我，我中有你：inplace merge 是简化的快速排序，单个步骤是 partition；stable partition 是简化的归并排序，单个步骤是 merge。")]),t._v(" "),a("p",[t._v("非常神奇。")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("想必有人不满意 "),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("O")]),a("mo",[t._v("(")]),a("mi",[t._v("n")]),a("mi",[t._v("log")]),a("mi",[t._v("n")]),a("mo",[t._v(")")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(n\\log n)")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.75em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),a("span",{staticClass:"mopen"},[t._v("(")]),a("span",{staticClass:"mord mathit"},[t._v("n")]),a("span",{staticClass:"mop"},[t._v("lo"),a("span",{staticStyle:{"margin-right":"0.01389em"}},[t._v("g")])]),a("span",{staticClass:"mord mathit"},[t._v("n")]),a("span",{staticClass:"mclose"},[t._v(")")])])])]),t._v(" 的时间复杂度吧。其实存在 "),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("O")]),a("mo",[t._v("(")]),a("mi",[t._v("n")]),a("mo",[t._v(")")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(n)")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.75em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),a("span",{staticClass:"mopen"},[t._v("(")]),a("span",{staticClass:"mord mathit"},[t._v("n")]),a("span",{staticClass:"mclose"},[t._v(")")])])])]),t._v(" 的原地稳定 merge 算法，这个算法也能很容易实现 "),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[t._v("O")]),a("mo",[t._v("(")]),a("mi",[t._v("n")]),a("mi",[t._v("log")]),a("mi",[t._v("n")]),a("mo",[t._v(")")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(n \\log n)")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.75em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),a("span",{staticClass:"mopen"},[t._v("(")]),a("span",{staticClass:"mord mathit"},[t._v("n")]),a("span",{staticClass:"mop"},[t._v("lo"),a("span",{staticStyle:{"margin-right":"0.01389em"}},[t._v("g")])]),a("span",{staticClass:"mord mathit"},[t._v("n")]),a("span",{staticClass:"mclose"},[t._v(")")])])])]),t._v(" 原地稳定排序，这边就挖个坑。")])])}),[],!1,null,null,null);a.default=n.exports}}]);