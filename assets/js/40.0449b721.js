(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{462:function(t,s,a){"use strict";a.r(s);var n=a(17),r=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"_1-前言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-前言"}},[t._v("#")]),t._v(" 1. 前言")]),t._v(" "),s("p",[t._v("最近我在想一个问题，既然语言的性能和它的编译器 / 解释器有很大的关系，那么是不是对于任何语言，经过适当优化，配上一个完美的编译器，都可以拥有 C 的性能？")]),t._v(" "),s("p",[t._v("所以我打算做一个，如何让 Python 拥有 C 的性能的思想实验。（口嗨罢了，事实上是有人做过这方面的努力的，而且是实际行动上）")]),t._v(" "),s("h2",{attrs:{id:"_2-虚拟机开销"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-虚拟机开销"}},[t._v("#")]),t._v(" 2. 虚拟机开销")]),t._v(" "),s("p",[t._v("众所周知，Python 是一个脚本语言，脚本语言和物理机之间隔了一层虚拟机。那么如何去掉这层虚拟机呢？答案当然是用编译器了。（这里的编译器指编译到机器码的编译器）")]),t._v(" "),s("h2",{attrs:{id:"_3-运行时类型信息"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-运行时类型信息"}},[t._v("#")]),t._v(" 3. 运行时类型信息")]),t._v(" "),s("p",[t._v("Python 是一个动态类型语言，我们可以任意修改变量的类型，这意味着我们可能无法在编译时确定变量的类型。")]),t._v(" "),s("p",[t._v("例如下面这段程序运行完后，鬼才知道 x 最终类型是 "),s("code",[t._v("int")]),t._v(" 还是 "),s("code",[t._v("float")]),t._v("：")]),t._v(" "),s("div",{staticClass:"language-py extra-class"},[s("pre",{pre:!0,attrs:{class:"language-py"}},[s("code",[t._v("x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("input")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.1")]),t._v("\n")])])]),s("p",[t._v("那么不确定变量类型有什么问题呢？")]),t._v(" "),s("p",[t._v("第一个影响是，每个值都额外需要一个类型信息，读取这个类型信息是有开销的。")]),t._v(" "),s("p",[t._v("第二个影响是编译器 / 解释器做不到对类型未知的变量进行优化。一个简单的例子是，如果 x 是无符号整型，那么 "),s("code",[t._v("x *= 2")]),t._v(" 可以优化为 "),s("code",[t._v("x <<= 1")]),t._v("。")]),t._v(" "),s("p",[t._v("所以我的解决方法是，让编译器读取类型标注（typing），并对违反类型标注的行为报 warning。")]),t._v(" "),s("div",{staticClass:"language-py extra-class"},[s("pre",{pre:!0,attrs:{class:"language-py"}},[s("code",[t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("input")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.1")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# warning")]),t._v("\n")])])]),s("h2",{attrs:{id:"_4-解引用开销"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-解引用开销"}},[t._v("#")]),t._v(" 4. 解引用开销")]),t._v(" "),s("p",[t._v("Python 的所有变量都是放在堆上的。解引用开销，其实就是每次访问一个变量都要通过引用（指针）间接地访问，相比于直接访问肯定是慢一点了。")]),t._v(" "),s("p",[t._v("我们知道，变量防在栈上的一个要求就是，这个变量是定长的（字节数固定）。这个好办，由于我们刚刚确定了变量的类型，定长也就呼之欲出了。（这里不包括 "),s("code",[t._v("list")]),t._v(" 等不定长类型）")]),t._v(" "),s("h2",{attrs:{id:"_5-gc-开销"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-gc-开销"}},[t._v("#")]),t._v(" 5. GC 开销")]),t._v(" "),s("p",[t._v("什么是 GC（Garbage Collection, 垃圾回收）？就是指一个变量诞生在堆上后，不需要人为把它释放掉，GC 来帮我们释放。")]),t._v(" "),s("p",[t._v("这个东西给程序员提供了很大的便利，只可惜我的目标是把 Python 优化成 C，因此这个“完美的编译器”必须在一定条件下编译出不带 GC 的程序。")]),t._v(" "),s("p",[t._v("受 C++ 的 RAII 和 Rust 所有权机制的影响，我觉得可以通过约束程序员的代码来实现所有权。")]),t._v(" "),s("ol",[s("li",[t._v("一个数据被一个变量独占（即所有权）")]),t._v(" "),s("li",[t._v("用弱引用（"),s("code",[t._v("weakref")]),t._v("）来实现借用")]),t._v(" "),s("li",[t._v("移动语义可以这么写："),s("code",[t._v("a = b; del b;")])]),t._v(" "),s("li",[t._v("一个数据离开作用域后被释放（在 Python 中是函数作用域）")])]),t._v(" "),s("p",[t._v("我要求，如果一个程序严格遵循 RAII，那么编译器必须编译出无 GC 的程序；反之编译器编译出带 GC 的程序。（这个编译器太智能了）")]),t._v(" "),s("h2",{attrs:{id:"_6-动态属性开销"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-动态属性开销"}},[t._v("#")]),t._v(" 6. 动态属性开销")]),t._v(" "),s("p",[t._v("Python 允许对象动态添加、删除属性。为了实现动态属性，其实对象内置了一个哈希表（"),s("code",[t._v("__dict__")]),t._v("）。")]),t._v(" "),s("p",[t._v("哈希表的开销不言而喻。我们首先要声明对象的 "),s("code",[t._v("__slots__")]),t._v("，这样禁止了添加属性的行为。其次只能用 "),s("code",[t._v("foo.bar")]),t._v(" 的方式访问属性，这样给了编译器优化的空间，优化成 C 不是梦想。")]),t._v(" "),s("p",[t._v("既然说到对象，继承也很有问题，不过这方面我了解太少就略过了。（有一说一，C 语言没有继承，要不把这个功能砍了？）")]),t._v(" "),s("h2",{attrs:{id:"_7-一些细节"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-一些细节"}},[t._v("#")]),t._v(" 7. 一些细节")]),t._v(" "),s("p",[t._v("之前说的其实都是“大道理”，在细节上还需要的优化太多了。")]),t._v(" "),s("p",[t._v("第一个是 "),s("code",[t._v("int")]),t._v(" 是没有范围的，相比与 C 的 32 位整数来说，是有一定开销的。因此为了让 "),s("code",[t._v("int")]),t._v(" 装作自己是 32 位整数，可以让它每次修改后断言一下。")]),t._v(" "),s("div",{staticClass:"language-py extra-class"},[s("pre",{pre:!0,attrs:{class:"language-py"}},[s("code",[t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("input")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("assert")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("31")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("31")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nx "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("assert")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("31")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("31")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("这段话就基本等价于 C 语言的：")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("int32_t")]),t._v(" x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("scanf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"%d"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nx "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("第二个是定长的数组，这个很好办，只要在初始化之后不出现修改数组长度的操作即可。")]),t._v(" "),s("p",[t._v("第三个是 Python 定义了很多异常，而在 C 里很多属于未定义行为（比如数组越界），不得不背离 Python 标准来提高性能了。")]),t._v(" "),s("h2",{attrs:{id:"_8-总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-总结"}},[t._v("#")]),t._v(" 8. 总结")]),t._v(" "),s("p",[t._v("写了好多，大致理了一遍脚本语言和 C/C++ 的区别。")]),t._v(" "),s("p",[t._v("经过一系列改造，Python 也许就能有 C 的性能了。不过就算有这么一个“完美的编译器”，直接上 C++/Rust 等语言它不香吗？")]),t._v(" "),s("p",[t._v("以上。")])])}),[],!1,null,null,null);s.default=r.exports}}]);